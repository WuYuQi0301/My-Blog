---
title: DM 多元线性模型预测房价
date: 2019-04-01 23:08:00
categories:
- Data Mining
---



双鸭山职业技术学校的附近的房价如何捏——买不起



梯度下降法GD
$$
\begin{align}\tau = 0:conv&ergence\\
\theta^{\tau+1}& = \theta^\tau-\rho(\tau)\triangledown logL(\theta^\tau|D)\\
&=\theta^\tau+\rho(\tau)\frac{1}{n}\sum^{n}_{i=1}(y_i-\theta^{(\tau)T}x_i)x_i
\end{align}
$$

随机梯度下降法SGD




两个参数abc

$h(x) = ax_1+bx_2$，其中$h$为房子总价，$x_1$为房子面积，$x_2$为距离





### Ex.1

![1](C:\Users\Yuki\Desktop\1.JPG)

![Figure_1](C:\Users\Yuki\Desktop\Figure_1.png)
![Figure_2](C:\Users\Yuki\Desktop\Figure_2.png)

### Ex.3

![2](C:\Users\Yuki\Desktop\2.JPG)

![Figure_3](C:\Users\Yuki\Desktop\Figure_3.png)





### Source Code

```python
import numpy as np
import matplotlib.pyplot as plt
from random import random

def hypothesis(a,b,x1,x2):
	return a * x1 + b * x2

iter_times = 1500000
lr = 1.5e-4
N = 50
test_N = 10
interval = 100000

a = 0.0
b = 0.0

price = np.zeros(N)
area = np.zeros(N)
distance = np.zeros(N)

test_price = np.zeros(test_N)
test_area = np.zeros(test_N)
test_distance = np.zeros(test_N)

# read in training data
with open('dataForTraining.txt', 'r') as f_train:
	i = 0
	for line in f_train.readlines():
		cha = line.strip('\n').split(' ')
		area[i] = float(cha[0])
		distance[i] = float(cha[1])
		price[i] = float(cha[2])
		i += 1
#read in test data
with open('dataForTesting.txt', 'r') as f_test:
	i = 0
	for line in f_test.readlines():
		cha = line.strip('\n').split(' ')
		test_area[i] = float(cha[0])
		test_distance[i] = float(cha[1])
		test_price[i] = float(cha[2])
		i += 1




# GD

step = []
err = []

iter_times = 20000
interval = 100
lr = 0.00015
e = 1e-8

for i in range(iter_times):
	delta = [hypothesis(a,b,area[j],distance[j])-price[j] for j in range(N)]
	a_ = a - lr * np.mean(delta*area)
	b_ = b - lr * np.mean(delta*distance)

	if i%interval == 0: 
		step.append(i)
		err.append(np.mean([pow((hypothesis(a_,b_,test_area[j],test_distance[j])-test_price[j]),2) for j in range(test_N)]))

	if (pow(a-a_, 2)+pow(b-b_,2)) < e:   #convergence
		a = a_
		b = b_
		print("GD: Convergence times : %d"%(i))
		break

	a = a_
	b = b_

print("final parameter : a = %f, b = %f"%(a,b))
plt.figure(1)
plt.plot(step,err)
plt.show()



#SGD

step2 = []
err2 = []

iter_times = 20000
interval = 100
lr = 0.00015
e = 1e-8


for i in range(iter_times):

	k = int(random()*N)
	a_ = a - lr * (hypothesis(a,b,area[k],distance[k])-price[k])*area[k]
	b_ = b - lr * (hypothesis(a,b,area[k],distance[k])-price[k])*distance[k]

	if i%interval == 0:
		step2.append(i)
		err2.append(np.mean([pow((hypothesis(a_,b_,test_area[j],test_distance[j])-test_price[j]),2) for j in range(test_N)]))

	if (pow(a-a_, 2)+pow(b-b_,2)) < e:   #converge
		a = a_
		b = b_
		print("SGD :Convergence times : %d"%(i))
		break

	a = a_
	b = b_

print("final parameter : a = %f, b = %f"%(a,b))
plt.figure(2)
plt.plot(step2,err2)
plt.show()
```

